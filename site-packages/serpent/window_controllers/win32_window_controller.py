from serpent.window_controller import WindowController

import win32gui
import win32api
import win32process

import ctypes
from ctypes import wintypes

import sys

# Importing pyautogui to fix frame extractor - this makes it extract the window size correctly
# See https://github.com/Martyn0324/SerpentAI/issues/3 for further information
import pyautogui

# Defines required Windows access rights.
PROCESS_VM_READ = 0x0010
PROCESS_VM_WRITE = 0x0020
PROCESS_VM_OPERATION = 0x0008

# Index for pulling a window handle.
GWLP_HINSTANCE = -6

SIZE_T = ctypes.c_size_t

class Win32WindowController(WindowController):

    def __init__(self):
        self.window_id = None
        self.process_id = None
        self.handle = None
        self.hProcess = None

    def locate_window(self, name):
        OpenProcess = ctypes.windll.kernel32.OpenProcess

        self.window_id = win32gui.FindWindow(None, name)

        # Gets neccesary data for memory reading
        self.process_id = (win32process.GetWindowThreadProcessId(self.window_id))[1]
        self.handle = win32api.GetWindowLong(self.window_id, GWLP_HINSTANCE)

        # Opens a process handle to the target application
        self.hProcess = OpenProcess(PROCESS_VM_READ | PROCESS_VM_WRITE | PROCESS_VM_OPERATION, False, self.process_id)

        return self.window_id

    def move_window(self, window_id, x, y):
        x0, y0, x1, y1 = win32gui.GetWindowRect(window_id)
        win32gui.MoveWindow(window_id, x, y, x1 - x0, y1 - y0, True)

    def resize_window(self, window_id, width, height):
        x0, y0, x1, y1 = win32gui.GetWindowRect(window_id)
        win32gui.MoveWindow(window_id, x0, y0, width, height, True)

    def focus_window(self, window_id):
        win32gui.SetForegroundWindow(window_id)

    def is_window_focused(self, window_id):
        focused_window_id = win32gui.GetForegroundWindow()
        return focused_window_id == window_id

    def get_focused_window_name(self):
        return win32gui.GetWindowText(win32gui.GetForegroundWindow())

# This function is probably the one causing the problem. Maybe replacing win32gui
# for pygetwindow could solve this

    def get_window_geometry(self, window_id):
        geometry = dict()

        x, y, width, height = win32gui.GetClientRect(window_id)

        geometry["width"] = width
        geometry["height"] = height

        x0, y0, x1, y1 = win32gui.GetWindowRect(window_id)

        border_width = ((x1 - x0 - width) // 2)

        geometry["x_offset"] = x0 + border_width
        geometry["y_offset"] = y0 + (y1 - y0 - height - border_width)

        return geometry

    def read_memory(self, address, size=4, pointer_offsets=None, add_handle=True, allow_partial=False):
        ReadProcessMemory = ctypes.windll.kernel32.ReadProcessMemory

        if add_handle:
            address += self.handle

        if pointer_offsets != None:
            for offset in pointer_offsets:
                read_address = int.from_bytes(self.read_memory(address, add_handle=False), sys.byteorder)
                address = read_address + offset

        # Creates buffer to store data in
        buf = (ctypes.c_char * size)()
        nread = SIZE_T()

        try:
            ReadProcessMemory(self.hProcess, address, buf, size, ctypes.byref(nread))
        except WindowsError as e:
            if not allow_partial or e.winerror != ERROR_PARTIAL_COPY:
                raise
        return buf[:nread.value]

    def write_memory(self, value, address, size=4, pointer_offsets=None, add_handle=True, allow_partial=False):
        WriteProcessMemory = ctypes.windll.kernel32.WriteProcessMemory
        GetLastError = ctypes.windll.kernel32.GetLastError

        if add_handle:
            address += self.handle

        if pointer_offsets != None:
            for offset in pointer_offsets:
                read_address = int.from_bytes(self.read_memory(address, add_handle=False), sys.byteorder)
                address = read_address + offset

        # Creates buffer to store data in
        buf = (ctypes.c_char * size)()
        nread = SIZE_T()


        # Writes value to buffer
        for i, val in enumerate(value):
            buf[i] = val

        try:
            write = WriteProcessMemory(self.hProcess, address, buf, size, ctypes.byref(nread))
        except WindowsError as e:
            if not allow_partial or e.winerror != ERROR_PARTIAL_COPY:
                raise
        if write == 0:
            raise Exception('Unable to write to memory.', ctypes.FormatError(GetLastError()))
